'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

var Browser = {
  // Firefox 1.0+
  isFirefox: function isFirefox() {
    // @ts-ignore
    return typeof InstallTrigger !== 'undefined';
  },
  // Internet Explorer 6-11
  isIE: function isIE() {
    // @ts-ignore
    return typeof window !== 'undefined' && !!window.MSInputMethodContext && !!document.documentMode;
  },
  // Edge 20+
  isEdge: function isEdge() {
    // @ts-ignore
    return !Browser.isIE() && !!window.StyleMedia;
  },
  // Chrome 1+
  isChrome: function isChrome() {
    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    // @ts-ignore
    return !!context.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);
  },
  // At least Safari 3+: "[object HTMLElementConstructor]"
  isSafari: function isSafari() {
    return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || navigator.userAgent.toLowerCase().indexOf('safari') !== -1;
  },
  // IOS Chrome
  isIOSChrome: function isIOSChrome() {
    return navigator.userAgent.toLowerCase().indexOf('crios') !== -1;
  }
};
var Browser$1 = Browser;

function cleanUp(config) {
  var onLoadingEnd = config.onLoadingEnd,
      onLoadingStart = config.onLoadingStart,
      onPrintDialogClose = config.onPrintDialogClose,
      frameId = config.frameId,
      printable = config.printable; // Check for a finished loading hook function

  onLoadingEnd === null || onLoadingEnd === void 0 ? void 0 : onLoadingEnd(); // If preloading pdf files, clean blob url

  if (onLoadingStart && typeof printable === 'string') window.URL.revokeObjectURL(printable); // Run onPrintDialogClose callback

  var event = 'mouseover';

  if (Browser$1.isChrome() || Browser$1.isFirefox()) {
    // Ps.: Firefox will require an extra click in the document to fire the focus event.
    event = 'focus';
  }

  var handler = function handler() {
    // Make sure the event only happens once.
    window.removeEventListener(event, handler);
    onPrintDialogClose === null || onPrintDialogClose === void 0 ? void 0 : onPrintDialogClose(); // Remove iframe from the DOM

    var iframe = document.getElementById(frameId);
    iframe === null || iframe === void 0 ? void 0 : iframe.remove();
  };

  window.addEventListener(event, handler);
}

function performPrint(iframeElement, config) {
  var onError = config.onError;

  try {
    // Probably allowing to make this work in Firefox without needing to focus the window again
    // iframeElement.focus();
    // If Edge or IE, try catch with execCommand
    if (Browser$1.isEdge() || Browser$1.isIE()) {
      try {
        var _iframeElement$conten;

        (_iframeElement$conten = iframeElement.contentWindow) === null || _iframeElement$conten === void 0 ? void 0 : _iframeElement$conten.document.execCommand('print', false);
      } catch (e) {
        var _iframeElement$conten2;

        (_iframeElement$conten2 = iframeElement.contentWindow) === null || _iframeElement$conten2 === void 0 ? void 0 : _iframeElement$conten2.print();
      }
    } else {
      var _iframeElement$conten3;

      // Other browsers
      (_iframeElement$conten3 = iframeElement.contentWindow) === null || _iframeElement$conten3 === void 0 ? void 0 : _iframeElement$conten3.print();
    }
  } catch (error) {
    onError === null || onError === void 0 ? void 0 : onError(error);
  } finally {
    if (Browser$1.isFirefox()) {
      // Move the iframe element off-screen and make it invisible
      iframeElement.style.visibility = 'hidden';
      iframeElement.style.left = '-1px';
    }

    cleanUp(config);
  }
}

function loadIframeImages(images) {
  var promises = images.map(function (image) {
    if (!image.src || image.src === window.location.href) return undefined;
    return loadIframeImage(image);
  });
  return Promise.all(promises);
}

function loadIframeImage(image) {
  return new Promise(function (resolve) {
    var pollImage = function pollImage() {
      !image || typeof image.naturalWidth === 'undefined' || image.naturalWidth === 0 || !image.complete ? setTimeout(pollImage, 500) : resolve(image);
    };

    pollImage();
  });
}

var print = function print(config, printFrame, printableElement) {
  var type = config.type,
      frameId = config.frameId,
      style = config.style; // Append iframe element to document body

  document.getElementsByTagName('body')[0].appendChild(printFrame); // Get iframe element

  var iframeElement = document.getElementById(frameId);
  if (!iframeElement) return; // Wait for iframe to load all content

  iframeElement.onload = function () {
    if (type === 'pdf') {
      // Add a delay for Firefox. In my tests, 1000ms was sufficient but 100ms was not
      if (Browser$1.isFirefox()) {
        setTimeout(function () {
          return performPrint(iframeElement, config);
        }, 1000);
      } else {
        performPrint(iframeElement, config);
      }

      return;
    } // Get iframe element document


    var printDocumentWindow = iframeElement.contentWindow || iframeElement.contentDocument;
    var printDocument = printDocumentWindow && 'document' in printDocumentWindow ? printDocumentWindow === null || printDocumentWindow === void 0 ? void 0 : printDocumentWindow.document : null;
    if (!printDocument) return; // Append printable element to the iframe body

    if (printableElement) printDocument.body.appendChild(printableElement); // Add custom style

    if (style) {
      // Create style element
      var styleEl = document.createElement('style');
      styleEl.innerHTML = style; // Append style element to iframe's head

      printDocument.head.appendChild(styleEl);
    } // If printing images, wait for them to load inside the iframe


    var images = printDocument.getElementsByTagName('img');

    if (images.length > 0) {
      loadIframeImages(Array.from(images)).then(function () {
        return performPrint(iframeElement, config);
      });
    } else {
      performPrint(iframeElement, config);
    }
  };
};

function addHeader(printElement, header, headerStyle) {
  // Create the header container div
  var headerContainer = document.createElement('div');

  if (!header) {
    return printElement.insertBefore(headerContainer, printElement.childNodes[0]);
  } // Check if the header is text or raw html


  if (isRawHTML(header)) {
    headerContainer.innerHTML = header;
  } else {
    // Create header element
    var headerElement = document.createElement('h1'); // Create header text node

    var headerNode = document.createTextNode(header); // Build and style

    headerElement.appendChild(headerNode);
    if (headerStyle) headerElement.setAttribute('style', headerStyle);
    headerContainer.appendChild(headerElement);
  }

  printElement.insertBefore(headerContainer, printElement.childNodes[0]);
}

function isRawHTML(raw) {
  // eslint-disable-next-line prefer-regex-literals
  var regexHtml = new RegExp('<([A-Za-z][A-Za-z0-9]*)\\b[^>]*>(.*?)</\\1>');
  return regexHtml.test(raw);
}

function html(config, printFrame) {
  var printable = config.printable,
      header = config.header,
      headerStyle = config.headerStyle; // Get the DOM printable element

  var printElement = document.getElementById(printable); // Check if the element exists

  if (!printElement) {
    window.console.error('Invalid HTML element id: ' + printable);
    return;
  } // Clone the target element including its children (if available)


  var clonedPrintable = cloneElement(printElement, config); // Add header

  if (header) {
    addHeader(clonedPrintable, header, headerStyle);
  } // Print html element contents


  print(config, printFrame, clonedPrintable);
}

function collectStyles(element, config) {
  var targetStyle = config.targetStyle,
      targetStyles = config.targetStyles;
  var win = document.defaultView || window; // String variable to hold styling for each element

  var elementStyle = ''; // Loop over computed styles

  var styles = win.getComputedStyle(element, '');

  for (var key = 0; key < styles.length; key++) {
    // Check if style should be processed
    if (targetStyles !== null && targetStyles !== void 0 && targetStyles.includes('*') || targetStyle !== null && targetStyle !== void 0 && targetStyle.includes(styles[key]) || targetStylesMatch(targetStyles || [], styles[key])) {
      if (styles.getPropertyValue(styles[key])) {
        elementStyle += "".concat(styles[key], ":").concat(styles.getPropertyValue(styles[key]), ";");
      }
    }
  }

  return elementStyle;
}

function targetStylesMatch(styles, value) {
  for (var i = 0; i < styles.length; i++) {
    if (_typeof(value) === 'object' && value.includes(styles[i])) return true;
  }

  return false;
}

function cloneElement(element, config) {
  var _getContext;

  var _config$ignoreElement = config.ignoreElements,
      ignoreElements = _config$ignoreElement === void 0 ? [] : _config$ignoreElement,
      scanStyles = config.scanStyles; // Clone the main node (if not already inside the recursion process)

  var clone = element.cloneNode(); // Loop over and process the children elements / nodes (including text nodes)

  var childNodesArray = Array.prototype.slice.call(element.childNodes);

  for (var i = 0; i < childNodesArray.length; i++) {
    // Check if we are skipping the current element
    if (ignoreElements.includes(childNodesArray[i].id)) {
      continue;
    } // Clone the child element


    var clonedChild = cloneElement(childNodesArray[i], config); // Attach the cloned child to the cloned parent node

    clone.appendChild(clonedChild);
  } // Get all styling for print element (for nodes of type element only)


  if (scanStyles && element.nodeType === 1) {
    clone.setAttribute('style', collectStyles(element, config));
  } // Check if the element needs any state processing (copy user input data)


  switch (element.tagName) {
    case 'SELECT':
      // Copy the current selection value to its clone
      clone.value = element.value;
      break;

    case 'CANVAS':
      // Copy the canvas content to its clone
      (_getContext = clone.getContext('2d')) === null || _getContext === void 0 ? void 0 : _getContext.drawImage(element, 0, 0);
      break;
  }

  return clone;
}

function image(config, printFrame) {
  var printable = config.printable,
      header = config.header,
      headerStyle = config.headerStyle; // Check if we are printing one image or multiple images
  // Create array with one image

  var images = Array.isArray(printable) ? printable : [printable]; // Create printable element (container)

  var printableElement = document.createElement('div'); // Create all image elements and append them to the printable container

  images.forEach(function (src) {
    // Create the image element
    var img = document.createElement('img'); // Set image src with the file url

    img.src = src; // The following block is for Firefox, which for some reason requires the image's src to be fully qualified in
    // order to print it

    if (Browser$1.isFirefox()) {
      var fullyQualifiedSrc = img.src;
      img.src = fullyQualifiedSrc;
    } // Create the image wrapper


    var imageWrapper = document.createElement('div'); // Append image to the wrapper element

    imageWrapper.appendChild(img); // Append wrapper to the printable element

    printableElement.appendChild(imageWrapper);
  }); // Check if we are adding a print header

  if (header) {
    addHeader(printableElement, header, headerStyle);
  } // Print image


  print(config, printFrame, printableElement);
}

function json(config, printFrame) {
  var printable = config.printable,
      repeatTableHeader = config.repeatTableHeader,
      properties = config.properties,
      header = config.header,
      headerStyle = config.headerStyle; // Check if we received proper data

  if (_typeof(printable) !== 'object') {
    throw new Error('Invalid javascript data object (JSON).');
  } // Validate repeatTableHeader


  if (typeof repeatTableHeader !== 'boolean') {
    throw new Error('Invalid value for repeatTableHeader attribute (JSON).');
  } // Validate properties


  if (!properties || !Array.isArray(properties)) {
    throw new Error('Invalid properties array for your JSON data.');
  } // We will format the property objects to keep the JSON api compatible with older releases


  var mappedProperties = properties.map(function (property) {
    return {
      field: _typeof(property) === 'object' ? property.field : property,
      displayName: _typeof(property) === 'object' ? property.displayName : property,
      columnSize: _typeof(property) === 'object' && property.columnSize ? "".concat(property.columnSize, ";") : "".concat(100 / properties.length, "%;")
    };
  });

  var mappedConfig = _objectSpread2(_objectSpread2({}, config), {}, {
    properties: mappedProperties
  }); // Create a print container element


  var printableElement = document.createElement('div'); // Build the printable html data

  printableElement.innerHTML += jsonToHTML(mappedConfig); // Check if we are adding a print header

  if (header) {
    addHeader(printableElement, header, headerStyle);
  } // Print the json data


  print(mappedConfig, printFrame, printableElement);
}

function capitalizePrint(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function jsonToHTML(_ref) {
  var printable = _ref.printable,
      properties = _ref.properties,
      repeatTableHeader = _ref.repeatTableHeader,
      gridHeaderStyle = _ref.gridHeaderStyle,
      gridStyle = _ref.gridStyle;
  // Get the row and column data
  var data = printable; // Create a html table

  var htmlData = '<table style="border-collapse: collapse; width: 100%;">'; // Check if the header should be repeated

  if (repeatTableHeader) {
    htmlData += '<thead>';
  } // Add the table header row


  htmlData += '<tr>'; // Add the table header columns

  for (var a = 0; a < properties.length; a++) {
    // eslint-disable-next-line max-len
    htmlData += '<th style="width:' + properties[a].columnSize + ';' + gridHeaderStyle + '">' + capitalizePrint(properties[a].displayName) + '</th>';
  } // Add the closing tag for the table header row


  htmlData += '</tr>'; // If the table header is marked as repeated, add the closing tag

  if (repeatTableHeader) {
    htmlData += '</thead>';
  } // Create the table body


  htmlData += '<tbody>'; // Add the table data rows

  for (var i = 0; i < data.length; i++) {
    // Add the row starting tag
    htmlData += '<tr>'; // Print selected properties only

    for (var n = 0; n < properties.length; n++) {
      var stringData = data[i]; // Support nested objects

      var property = properties[n].field.split('.');

      if (property.length > 1) {
        for (var p = 0; p < property.length; p++) {
          // @ts-ignore
          stringData = stringData[property[p]];
        }
      } else {
        // @ts-ignore
        stringData = stringData[properties[n].field];
      } // Add the row contents and styles


      htmlData += '<td style="width:' + properties[n].columnSize + gridStyle + '">' + stringData + '</td>';
    } // Add the row closing tag


    htmlData += '</tr>';
  } // Add the table and body closing tags


  htmlData += '</tbody></table>';
  return htmlData;
}

function pdf(config, printFrame) {
  var base64 = config.base64,
      printable = config.printable,
      onError = config.onError; // Check if we have base64 data

  if (base64) {
    var bytesArray = Uint8Array.from(window.atob(printable), function (c) {
      return c.charCodeAt(0);
    });
    createBlobAndPrint(config, printFrame, bytesArray);
    return;
  } // Format pdf url


  var pdfUrl = /^(blob|http|\/\/)/i.test(printable) ? printable : window.location.origin + (printable.charAt(0) !== '/' ? '/' + printable : printable); // Get the file through a http request (Preload)

  var req = new window.XMLHttpRequest();
  req.responseType = 'arraybuffer';
  req.addEventListener('error', function () {
    cleanUp(_objectSpread2(_objectSpread2({}, config), {}, {
      printable: pdfUrl
    }));
    onError === null || onError === void 0 ? void 0 : onError(req.statusText, req); // Since we don't have a pdf document available, we will stop the print job
  });
  req.addEventListener('load', function () {
    // Check for errors
    if (![200, 201].includes(req.status)) {
      cleanUp(config);
      onError === null || onError === void 0 ? void 0 : onError(req.statusText, req); // Since we don't have a pdf document available, we will stop the print job

      return;
    } // Print requested document


    createBlobAndPrint(config, printFrame, req.response);
  });
  req.open('GET', printable, true);
  req.send();
}

function createBlobAndPrint(config, printFrame, data) {
  // Pass response or base64 data to a blob and create a local object url
  var localPdfBlb = new window.Blob([data], {
    type: 'application/pdf'
  });
  var localPdf = window.URL.createObjectURL(localPdfBlb); // Set iframe src with pdf document url

  printFrame.setAttribute('src', localPdf);
  print(config, printFrame);
}

function rawHtml(config, printFrame) {
  var printable = config.printable; // Create printable element (container)

  var printableElement = document.createElement('div');
  printableElement.setAttribute('style', 'width:100%'); // Set our raw html as the printable element inner html content

  printableElement.innerHTML = printable; // Print html contents

  print(config, printFrame, printableElement);
}

var printTypes = ['pdf', 'html', 'image', 'json', 'raw-html'];
var baseConfig = {
  type: 'pdf',
  documentTitle: 'Document',
  frameId: 'prntr',
  onError: function onError(error) {
    throw new Error(error);
  }
};
var basePdfConfig = {
  base64: false
};
var baseHtmlConfig = {
  targetStyle: ['clear', 'display', 'width', 'min-width', 'height', 'min-height', 'max-height'],
  targetStyles: ['border', 'box', 'break', 'text-decoration'],
  ignoreElements: [],
  scanStyles: true
};
var baseJsonConfig = {
  gridHeaderStyle: 'font-weight: bold; padding: 5px; border: 1px solid #dddddd;',
  gridStyle: 'border: 1px solid lightgray; margin-bottom: -1px;',
  repeatTableHeader: true
};

function prntr(config) {
  var printConfig = _objectSpread2(_objectSpread2({}, baseConfig), config); // Process parameters


  validateConfig(printConfig); // Start

  start(printConfig);
}

function validateConfig(_ref) {
  var type = _ref.type,
      printable = _ref.printable;

  // Validate printable
  if (!printable) {
    throw new Error('Missing printable information.');
  } // Validate type


  if (!type || typeof type !== 'string' || !printTypes.includes(type.toLowerCase())) {
    throw new Error('Invalid print type. Available types are: pdf, html, raw-html, image and json.');
  }
}

function start(config) {
  var onLoadingStart = config.onLoadingStart,
      frameId = config.frameId; // Check for a print start hook function

  onLoadingStart === null || onLoadingStart === void 0 ? void 0 : onLoadingStart(); // To prevent duplication and issues, remove any used printFrame from the DOM

  clearPrintFrames(frameId); // Create a new iframe for the print job

  var printFrame = getPrintFrame(config); // Check printable type

  switch (config.type) {
    case 'pdf':
      startPdf(_objectSpread2(_objectSpread2({}, basePdfConfig), config), printFrame);
      break;

    case 'image':
      image(config, printFrame);
      break;

    case 'html':
      html(_objectSpread2(_objectSpread2({}, baseHtmlConfig), config), printFrame);
      break;

    case 'raw-html':
      rawHtml(config, printFrame);
      break;

    case 'json':
      json(_objectSpread2(_objectSpread2({}, baseJsonConfig), config), printFrame);
      break;
  }
}

function getFallbackPrintable(_ref2) {
  var printable = _ref2.printable,
      fallbackPrintable = _ref2.fallbackPrintable,
      base64 = _ref2.base64;

  if (fallbackPrintable) {
    return base64 ? "data:application/pdf;base64,".concat(fallbackPrintable) : fallbackPrintable;
  }

  return base64 ? "data:application/pdf;base64,".concat(printable) : printable;
}

function startPdf(config, printFrame) {
  var onLoadingEnd = config.onLoadingEnd,
      onIncompatibleBrowser = config.onIncompatibleBrowser,
      onError = config.onError; // Check browser support for pdf and if not supported we will just open the pdf file instead

  if (Browser$1.isIE()) {
    try {
      console.info('Prntr doesn\'t support PDF printing in Internet Explorer.');
      var fallbackPrintable = getFallbackPrintable(config);
      if (!fallbackPrintable) throw new Error('Prntr can not print fallbackPrintable');
      var win = window.open(fallbackPrintable, '_blank');
      win === null || win === void 0 ? void 0 : win.focus();
      onIncompatibleBrowser === null || onIncompatibleBrowser === void 0 ? void 0 : onIncompatibleBrowser();
    } catch (error) {
      onError === null || onError === void 0 ? void 0 : onError(error);
    } finally {
      onLoadingEnd === null || onLoadingEnd === void 0 ? void 0 : onLoadingEnd();
    }

    return;
  }

  pdf(config, printFrame);
}

function clearPrintFrames(frameId) {
  var _usedFrame$parentNode;

  var usedFrame = document.getElementById(frameId);
  if (!usedFrame) return;
  (_usedFrame$parentNode = usedFrame.parentNode) === null || _usedFrame$parentNode === void 0 ? void 0 : _usedFrame$parentNode.removeChild(usedFrame);
}

function getPrintFrame(_ref3) {
  var type = _ref3.type,
      documentTitle = _ref3.documentTitle,
      css = _ref3.css,
      frameId = _ref3.frameId;
  // Create a new iframe for the print job
  var printFrame = document.createElement('iframe'); // Set iframe element id

  printFrame.setAttribute('id', frameId);

  if (Browser$1.isFirefox()) {
    // Set the iframe to be is visible on the page (guaranteed by fixed position) but hidden using opacity 0, because
    // this works in Firefox. The height needs to be sufficient for some part of the document other than the PDF
    // viewer's toolbar to be visible in the page
    // eslint-disable-next-line max-len
    printFrame.setAttribute('style', 'width: 1px; height: 100px; position: fixed; left: 0; top: 0; opacity: 0; border-width: 0; margin: 0; padding: 0');
  } else {
    // Hide the iframe in other browsers
    printFrame.setAttribute('style', 'visibility: hidden; height: 0; width: 0; position: absolute; border: 0');
  } // For non pdf printing, pass an html document string to srcdoc (force onload callback)


  if (type !== 'pdf') {
    printFrame.srcdoc = "<html><head><title>".concat(documentTitle, "</title>"); // Attach css files

    if (css) {
      var styles = Array.isArray(css) ? css : [css]; // Create link tags for each css file

      styles.forEach(function (file) {
        printFrame.srcdoc += "<link rel=\"stylesheet\" href=\"".concat(file, "\">");
      });
    }

    printFrame.srcdoc += '</head><body></body></html>';
  }

  return printFrame;
}

if (typeof window !== 'undefined') {
  window.prntr = prntr;
}

exports["default"] = prntr;
